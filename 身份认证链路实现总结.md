# 🔐 身份认证链路实现总结

## ✅ 已实现的功能

### 1. 前端路由保护 ✅

**文件：** `middleware.ts`

- ✅ 保护 `/dream-factory` 路由
- ✅ 未登录自动跳转到 `/auth/login`
- ✅ 登录后自动跳转回原页面

### 2. 前端 API 路由认证 ✅

**文件：**
- `app/api/ai/generate-text/route.ts`
- `app/api/ai/generate-image/route.ts`
- `app/api/ai/generate-job/route.ts`

- ✅ 所有生成接口检查登录状态
- ✅ 未登录返回 401 错误
- ✅ 自动携带后端 API token

### 3. 后端 API 客户端 ✅

**文件：** `lib/backend-api-client.ts`

- ✅ 自动获取后端 token（使用 session email + 配置的密码）
- ✅ 自动在请求头中携带 `Authorization: Bearer <token>`
- ✅ 提供 `getCurrentUserInfo()` 方法获取用户信息

### 4. 后端 /me 接口 ✅

**文件：** `backend-api/src/auth/auth.controller.ts`

- ✅ 返回用户信息：`userId`, `email`, `balance`
- ✅ 返回模式信息：`billingMode`, `modelMode`
- ✅ 根据环境变量和用户白名单决定模式
- ✅ 使用 `@CurrentUser()` 装饰器，不允许前端传 userId

### 5. 前端用户信息显示 ✅

**文件：** `app/dream-factory/page.tsx`

- ✅ 右上角显示用户信息
- ✅ 显示余额
- ✅ 显示模式（DRY_RUN/REAL）
- ✅ 退出登录按钮

---

## 📝 文件变更清单

### 新增文件

1. **`lib/backend-api-client.ts`**
   - 后端 API 客户端，自动处理认证

### 修改文件

1. **`middleware.ts`**
   - 增加 `/dream-factory` 路由保护

2. **`app/api/ai/generate-text/route.ts`**
   - 增加登录检查
   - 使用 `callBackendAPI` 调用后端

3. **`app/api/ai/generate-image/route.ts`**
   - 增加登录检查

4. **`app/api/ai/generate-job/route.ts`**
   - 增加登录检查

5. **`app/dream-factory/page.tsx`**
   - 增加用户信息显示
   - 调用 `/me` 接口获取用户信息

6. **`backend-api/src/auth/auth.controller.ts`**
   - 新增 `MeController` 和 `/me` 接口

7. **`backend-api/src/auth/auth.module.ts`**
   - 导入 `CreditsModule` 和注册 `MeController`

---

## 🔧 环境变量配置

### 前端环境变量（`.env.local` 或 Vercel）

```env
# NextAuth 配置（必需）
NEXTAUTH_SECRET=你的密钥
NEXTAUTH_URL=http://localhost:3000  # 或生产环境 URL

# 管理员账号（用于前端登录）
ADMIN_USERS=admin:admin123,test:test123

# 后端 API 配置
NEXT_PUBLIC_BACKEND_API_URL=https://api.factory-buy.com

# 后端登录密码（用于获取后端 token）
# 注意：这个密码需要与后端 USER_WHITELIST 中的密码匹配
BACKEND_TEST_PASSWORD=password123
```

### 后端环境变量（服务器 `.env`）

```env
# JWT 密钥（必须与前端 NEXTAUTH_SECRET 相同）
JWT_SECRET=你的密钥（与前端相同）
NEXTAUTH_SECRET=你的密钥（与前端相同）

# 用户白名单（格式：email:password,email2:password2）
# 注意：密码需要与前端 ADMIN_USERS 或 BACKEND_TEST_PASSWORD 匹配
USER_WHITELIST=test@factory-buy.com:password123,admin@factory-buy.com:admin123

# Dry Run 模式配置（默认关闭真实调用）
MODEL_ENABLED=false          # 禁用真实模型调用
BILLING_ENABLED=false        # 禁用真实扣费

# 真实模式用户白名单（可选）
# 如果配置，这些用户将使用 REAL 模式，其他用户使用 DRY_RUN
REAL_MODE_USERS=admin@factory-buy.com

# 初始积分
INITIAL_CREDITS=100
```

---

## ✅ 验证步骤

### 步骤 1：配置环境变量

**前端：**
```bash
# 在 .env.local 中添加
NEXTAUTH_SECRET=你的密钥
ADMIN_USERS=test:test123
BACKEND_TEST_PASSWORD=test123
NEXT_PUBLIC_BACKEND_API_URL=https://api.factory-buy.com
```

**后端：**
```bash
# 在服务器 .env 中添加
JWT_SECRET=你的密钥（与前端相同）
USER_WHITELIST=test@factory-buy.com:test123
MODEL_ENABLED=false
BILLING_ENABLED=false
```

### 步骤 2：重启服务

**前端：**
```bash
npm run dev
```

**后端：**
```bash
pm2 restart ue-assets-backend --update-env
```

### 步骤 3：测试登录保护

1. **访问 `/dream-factory`（未登录）**
   - 应该自动跳转到 `/auth/login`
   - ✅ 验证通过

2. **登录**
   - 使用配置的用户名和密码登录
   - 应该自动跳转回 `/dream-factory`
   - ✅ 验证通过

### 步骤 4：测试用户信息显示

1. **登录后访问 `/dream-factory`**
   - 右上角应该显示用户信息
   - 显示余额和模式（DRY_RUN/REAL）
   - ✅ 验证通过

### 步骤 5：测试 API 认证

1. **未登录调用生成接口**
   ```bash
   curl -X POST http://localhost:3000/api/ai/generate-text \
     -H "Content-Type: application/json" \
     -d '{"prompt":"测试"}'
   ```
   - 应该返回 401 错误
   - ✅ 验证通过

2. **登录后调用生成接口**
   - 应该正常调用后端 API
   - 后端应该识别 userId
   - ✅ 验证通过

### 步骤 6：测试 /me 接口

```bash
# 1. 登录获取 token
TOKEN=$(curl -X POST https://api.factory-buy.com/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@factory-buy.com","password":"test123"}' \
  | jq -r '.token')

# 2. 调用 /me 接口
curl https://api.factory-buy.com/me \
  -H "Authorization: Bearer $TOKEN" | jq .
```

**预期结果：**
```json
{
  "userId": "test@factory-buy.com",
  "email": "test@factory-buy.com",
  "balance": 100,
  "billingMode": "DRY_RUN",
  "modelMode": "DRY_RUN"
}
```

### 步骤 7：测试 Dry Run 模式

1. **配置 `MODEL_ENABLED=false` 和 `BILLING_ENABLED=false`**
2. **调用生成接口**
   - 应该返回 mock 数据
   - 余额不应该变化
   - ✅ 验证通过

---

## 🔍 关键实现细节

### 1. 身份识别链路

```
前端登录 (NextAuth)
  ↓
Session (JWT)
  ↓
前端 API 路由检查 session
  ↓
获取后端 token (使用 session.email + 配置的密码)
  ↓
调用后端 API (携带 Authorization: Bearer token)
  ↓
后端 AuthGuard 验证 token
  ↓
@CurrentUser() 获取 userId (从 token 解析，无法伪造)
```

### 2. 模式控制逻辑

```typescript
// 默认模式（安全）
const modelEnabled = process.env.MODEL_ENABLED !== 'false';  // 默认 false
const billingEnabled = process.env.BILLING_ENABLED !== 'false';  // 默认 false

// 用户白名单覆盖（可选）
if (realModeUsers.includes(user.email)) {
  finalModelMode = 'REAL';
  finalBillingMode = 'REAL';
}
```

### 3. 安全性保证

- ✅ 前端无法伪造 userId（从 JWT token 解析）
- ✅ 未登录无法调用生成接口（401 错误）
- ✅ 后端使用 `@CurrentUser()` 装饰器，不允许前端传 userId
- ✅ 默认 DRY_RUN 模式（安全）

---

## 📋 配置检查清单

### 前端配置

- [ ] `NEXTAUTH_SECRET` 已配置
- [ ] `ADMIN_USERS` 已配置（至少一个用户）
- [ ] `BACKEND_TEST_PASSWORD` 已配置（与后端 USER_WHITELIST 匹配）
- [ ] `NEXT_PUBLIC_BACKEND_API_URL` 已配置

### 后端配置

- [ ] `JWT_SECRET` 已配置（与前端 NEXTAUTH_SECRET 相同）
- [ ] `USER_WHITELIST` 已配置（至少一个用户，密码与前端匹配）
- [ ] `MODEL_ENABLED=false` 已配置（Dry Run 模式）
- [ ] `BILLING_ENABLED=false` 已配置（Dry Run 模式）
- [ ] `INITIAL_CREDITS` 已配置

### 功能验证

- [ ] `/dream-factory` 路由保护正常
- [ ] 登录后显示用户信息
- [ ] `/me` 接口返回正确信息
- [ ] 生成接口需要登录（401 保护）
- [ ] Dry Run 模式正常工作

---

## 🚀 快速测试脚本

```bash
#!/bin/bash

# 测试身份认证链路

BACKEND_URL="https://api.factory-buy.com"
EMAIL="test@factory-buy.com"
PASSWORD="test123"

echo "🧪 测试身份认证链路..."
echo ""

# 1. 登录获取 token
echo "1️⃣ 登录..."
TOKEN=$(curl -s -X POST $BACKEND_URL/auth/login \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}" \
  | jq -r '.token')

if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
  echo "❌ 登录失败"
  exit 1
fi
echo "✅ 登录成功"
echo ""

# 2. 调用 /me 接口
echo "2️⃣ 获取用户信息..."
ME_RESPONSE=$(curl -s $BACKEND_URL/me \
  -H "Authorization: Bearer $TOKEN")

echo "$ME_RESPONSE" | jq .

if echo "$ME_RESPONSE" | jq -e '.userId' > /dev/null; then
  echo "✅ /me 接口正常"
else
  echo "❌ /me 接口异常"
  exit 1
fi
echo ""

# 3. 测试生成接口（需要认证）
echo "3️⃣ 测试生成接口（需要认证）..."
GENERATE_RESPONSE=$(curl -s -X POST $BACKEND_URL/ai/generate-text \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "prompt": "测试",
    "presetId": "qwen-turbo-standard"
  }')

if echo "$GENERATE_RESPONSE" | jq -e '.text' > /dev/null; then
  echo "✅ 生成接口正常（已认证）"
else
  echo "❌ 生成接口异常"
  echo "$GENERATE_RESPONSE" | jq .
  exit 1
fi
echo ""

# 4. 测试未认证调用（应该失败）
echo "4️⃣ 测试未认证调用（应该返回 401）..."
UNAUTH_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST $BACKEND_URL/ai/generate-text \
  -H "Content-Type: application/json" \
  -d '{"prompt":"测试","presetId":"qwen-turbo-standard"}')

HTTP_CODE=$(echo "$UNAUTH_RESPONSE" | tail -n 1)
if [ "$HTTP_CODE" == "401" ]; then
  echo "✅ 未认证调用正确返回 401"
else
  echo "❌ 未认证调用未返回 401（实际: $HTTP_CODE）"
  exit 1
fi
echo ""

echo "🎉 所有测试通过！"
```

---

## 📝 注意事项

1. **密码同步**：前端 `ADMIN_USERS` 或 `BACKEND_TEST_PASSWORD` 的密码必须与后端 `USER_WHITELIST` 中的密码匹配

2. **JWT Secret 同步**：前端 `NEXTAUTH_SECRET` 必须与后端 `JWT_SECRET` 相同

3. **默认安全**：默认使用 DRY_RUN 模式，只有配置了 `REAL_MODE_USERS` 的用户才使用 REAL 模式

4. **Token 获取**：前端使用 session.email + 配置的密码登录后端获取 token，这个 token 用于后续 API 调用

---

## ✅ 完成状态

- [x] 路由保护
- [x] API 认证
- [x] 后端 /me 接口
- [x] 前端用户信息显示
- [x] Dry Run 模式支持
- [x] 环境变量配置文档
- [x] 验证步骤文档

**所有功能已实现！** 🎉







